{
  "version": 3,
  "sources": ["../lib/fn/modules/cache.js", "../lib/fn/modules/curry.js", "../lib/fn/modules/get.js", "../lib/dom/modules/classes.js", "../lib/bolt/classes/device.js", "../lib/fn/modules/last.js", "../lib/fn/modules/to-array.js", "../lib/dom/modules/select.js", "../lib/dom/modules/is-text-node.js", "../lib/dom/scripts/orphans.js", "../lib/fn/modules/signal.js", "../lib/fn/modules/id.js", "../lib/fn/modules/overload.js", "../lib/fn/modules/noop.js", "../lib/dom/modules/assign.js", "../lib/dom/modules/create.js", "../lib/fn/modules/to-type.js", "../lib/fn/modules/stream/stream.js", "../lib/dom/modules/events.js", "../lib/dom/modules/is-primary-button.js", "../lib/fn/modules/parse-value.js", "../lib/fn/modules/to-rad.js", "../lib/fn/modules/parse-angle.js", "../lib/dom/modules/style.js", "../lib/dom/modules/parse-length.js", "../lib/dom/modules/trigger.js", "../lib/fn/modules/exec.js", "../lib/fn/modules/capture.js", "../lib/dom/modules/element/internals.js", "../lib/dom/modules/element.js", "../lib/details-toggle/module.js", "../lib/site/module.js"],
  "sourcesContent": ["/**\ncache(fn)\nReturns a function that caches the output values of `fn(input)` against input\nvalues in a map, such that for each input value `fn` is only ever called once.\n*/\n\nlet warned;\n\nexport default function cacheByObject(fn) {\n    var map = new Map();\n\n    return function cache(object) {\n        if (window.DEBUG && !warned && object === undefined) {\n            warned = true;\n            console.warn('cache() called with undefined. Not illegal, but potentially bad.');\n        }\n\n        if (window.DEBUG && arguments.length > 1) {\n            console.warn('cache() called with ' + arguments.length + ' arguments. Accepts exactly 1.');\n        }\n\n        if (map.has(object)) {\n            return map.get(object);\n        }\n\n        var value = fn(object);\n        map.set(object, value);\n        return value;\n    };\n}\n", "/**\ncurry(fn [, muteable, arity])\nReturns a function that wraps `fn` and makes it partially applicable.\n*/\n\nimport cache from './cache.js';\n\nconst A     = Array.prototype;\n\nfunction applyFn(fn, args) {\n    return typeof fn === 'function' ? fn.apply(null, args) : fn ;\n}\n\nfunction curry(fn, muteable, arity) {\n    arity = arity || fn.length;\n\n    var memo = arity === 1 ?\n        // Don't cache if `muteable` flag is true\n        muteable ? fn : cache(fn) :\n\n        // It's ok to always cache intermediate memos, though\n        cache(function(object) {\n            return curry(function() {\n                var args = [object];\n                args.push.apply(args, arguments);\n                return fn.apply(null, args);\n            }, muteable, arity - 1) ;\n        }) ;\n\n    return function partial(object) {\n        return arguments.length === 0 ?\n            partial :\n        arguments.length === 1 ?\n            memo(object) :\n        arguments.length >= arity ?\n            fn.apply(null, arguments) :\n        // This is bad, I think. We don't want [[fn],[fn]].map(get(0)) to be firing the fns\n        //arguments.length > arity ?\n        //    applyFn(fn.apply(null, A.splice.call(arguments, 0, arity)), arguments) :\n        applyFn(memo(object), A.slice.call(arguments, 1)) ;\n    };\n}\n\n//function curry(fn, muteable, arity) {\n//    arity = arity || fn.length;\n//    return function curried() {\n//        return arguments.length >= arity ?\n//            fn.apply(null, arguments) :\n//            curried.bind(null, ...arguments) ;\n//    };\n//}\n\nif (window.DEBUG) {\n    const _curry = curry;\n\n    // Feature test\n\tconst isFunctionLengthDefineable = (function() {\n\t\tvar fn = function() {};\n\n\t\ttry {\n\t\t\t// Can't do this on Safari - length non configurable :(\n\t\t\tObject.defineProperty(fn, 'length', { value: 2 });\n\t\t}\n\t\tcatch(e) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn fn.length === 2;\n\t})();\n\n    const setFunctionProperties = function setFunctionProperties(text, parity, fn1, fn2) {\n        // Make the string representation of fn2 display parameters of fn1\n        fn2.toString = function() {\n            return /function\\s*[\\w\\d]*\\s*\\([,\\w\\d\\s]*\\)/.exec(fn1.toString()) + ' { [' + text + '] }';\n        };\n\n        // Where possible, define length so that curried functions show how\n        // many arguments they are yet expecting\n        if (isFunctionLengthDefineable) {\n            Object.defineProperty(fn2, 'length', { value: parity });\n        }\n\n        return fn2;\n    };\n\n    // Make curried functions log a pretty version of their partials\n    curry = function curry(fn, muteable, arity) {\n        arity  = arity || fn.length;\n        return setFunctionProperties('curried', arity, fn, _curry(fn, muteable, arity));\n    };\n}\n\n\nexport default curry;\n", "\n/**\nget(name, object)\nGet property `name` of `object`.\n*/\n\nimport curry from './curry.js';\n\nexport function get(key, object) {\n    // Todo? Support WeakMaps and Maps and other map-like objects with a\n    // get method - but not by detecting the get method\n    return object[key];\n}\n\nexport default curry(get, true);\n", "\n/**\nclasses(node)\nReturns the classList of `node`.\n*/\n\nimport curry from 'fn/curry.js';\nimport get   from 'fn/get.js';\n\nconst classes = get('classList');\n\nexport default classes;\n\n/**\naddClass(class, node)\nAdds `'class'` to the classList of `node`.\n*/\n\nfunction _addClass(string, node) {\n\tclasses(node).add(string);\n}\n\n/**\nremoveClass(class, node)\nRemoves `'class'` from the classList of `node`.\n*/\n\nfunction _removeClass(string, node) {\n\tclasses(node).remove(string);\n}\n\nfunction requestFrame(n, fn) {\n\t// Requst frames until n is 0, then call fn\n\t(function frame(t) {\n\t\treturn n-- ?\n\t\t\trequestAnimationFrame(frame) :\n\t\t\tfn(t);\n\t})();\n}\n\nfunction _frameClass(string, node) {\n\tvar list = classes(node);\n\tlist.add(string);\n\n\t// Chrome (at least) requires 2 frames - I guess in the first, the\n\t// change is painted so we have to wait for the second to undo\n\trequestFrame(2, () => list.remove(string));\n}\n\nexport const addClass    = curry(_addClass, true);\nexport const removeClass = curry(_removeClass, true);\nexport const frameClass  = curry(_frameClass, true);\n", "\n// Adds a class to the document root depending on the last input device\n// used, enabling you to set :focus and :hover styles depending on the type of\n// input responible for them. Hopefully. Not foolproof, but better than getting\n// rid of focus outlines altogether.\n\nimport classes from 'dom/classes.js';\n\nexport const config = {\n    simulatedEventDelay: 0.08,\n    keyClass:   'key-device',\n    mouseClass: 'mouse-device',\n    touchClass: 'touch-device',\n    keyType:    'key',\n    mouseType:  'mouse',\n    touchType:  'touch'\n};\n\nexport const device = {\n    type: 'mouse'\n};\n\nvar list       = classes(document.documentElement);\nvar currentClass, timeStamp;\n\nfunction updateClass(newClass) {\n    // We are already in mouseClass state, nothing to do\n    if (currentClass === newClass) { return; }\n    list.remove(currentClass);\n    list.add(newClass);\n    currentClass = newClass;\n}\n\nfunction mousedown(e) {\n    // If we are within simulatedEventDelay of a touchend event, ignore\n    // mousedown as it's likely a simulated event. Reset timeStamp to\n    // gaurantee that we only block one mousedown at most.\n    if (e.timeStamp < timeStamp + config.simulatedEventDelay * 1000) { return; }\n    timeStamp = undefined;\n    updateClass(config.mouseClass);\n    device.type = config.mouseType;\n}\n\nfunction keydown(e) {\n    // If key is not tab, enter or escape do nothing\n    if ([\"ArrowDown\", \"ArrowUp\", \"ArrowRight\", \"ArrowLeft\", \"Space\", \"Escape\", \"Tab\"].indexOf(e.code) === -1) { return; }\n    updateClass(config.keyClass);\n    device.type = config.keyType;\n    timeStamp = e.timeStamp;\n}\n\nfunction touchend(e) {\n    timeStamp = e.timeStamp;\n    updateClass(config.touchClass);\n    device.type = config.touchType;\n}\n\ndocument.addEventListener('mousedown', mousedown);\ndocument.addEventListener('keydown', keydown);\ndocument.addEventListener('touchend', touchend);\n", "/**\nlast(array)\nReturns the last value in an array.\n**/\n\nexport default function last(array) {\n    if (typeof array.length === 'number') {\n        return array[array.length - 1];\n    }\n}\n", "/**\ntoArray(object)\n*/\n\nexport default function toArray(object) {\n    if (object.toArray) { return object.toArray(); }\n\n    // Speed test for array conversion:\n    // https://jsperf.com/nodelist-to-array/27\n\n    var array = [];\n    var l = object.length;\n    var i;\n\n    if (typeof object.length !== 'number') { return array; }\n\n    array.length = l;\n\n    for (i = 0; i < l; i++) {\n        array[i] = object[i];\n    }\n\n    return array;\n}\n", "\n/**\nselect(selector, node)\n\nReturns an array of all descendants of `node` that match `selector`.\n*/\n\nimport curry from 'fn/curry.js';\nimport toArray from 'fn/to-array.js';\n\nexport function select(selector, node) {\n\treturn toArray(node.querySelectorAll(selector));\n}\n\nexport default curry(select, true)\n", "\n/**\nisTextNode(node)\nReturns `true` if `node` is a text node.\n**/\n\nexport default function isTextNode(node) {\n    return node.nodeType === 3;\n}\n", "\nimport get        from 'fn/get.js';\nimport last       from 'fn/last.js';\nimport select     from '../../dom/modules/select.js';\nimport isTextNode from '../../dom/modules/is-text-node.js';\n\n// Prevent orphans at the end of paragraphs and headings\nselect('h1, h2, h3, h4, h5, h6, p, li', document.body)\n.map(get('childNodes'))\n.map(last)\n.filter(isTextNode)\n.forEach((node) =>\n    node.textContent = node.textContent.replace(/\\s+(\\S+)\\s*$/, ($0, $1) =>\n        // Insert no breaking space\n        '\\u00A0' + $1\n    )\n);\n", "\nconst DEBUG  = false;//window.DEBUG && window.DEBUG.signal !== false;\nconst assign = Object.assign;\n\nlet evaluatingSignal;\nlet id = 0;\n\n\nfunction removeInput(signal, input) {\n    // Remove input from stream\n    let i = 0;\n    while (signal[--i] && signal[i] !== input);\n    while (signal[i--]) signal[i + 1] = signal[i];\n}\n\nfunction removeOutput(signal, output) {\n    // Remove output from stream\n    let o = -1;\n    while (signal[++o] && signal[o] !== output);\n    while (signal[o++]) signal[o - 1] = signal[o];\n}\n\nfunction setDependency(signal, dependent) {\n    // Set signal as an input of dependent\n    let n = 0;\n    while (dependent[--n]) if (dependent[n] === signal) break;\n    dependent[n] = signal;\n\n    // Set dependent as an output of signal\n    n = -1;\n    while (signal[++n]) if (signal[n] === dependent) break;\n    signal[n] = dependent;\n\n    if (DEBUG) console.log(\n        '%cSignal%c connect%c ' + signal.constructor.name + '#' + signal.id + ' - ' + dependent.constructor.name + '#' + dependent.id,\n        'color: #718893; font-weight: 300;',\n        'color: #3896BF; font-weight: 300;',\n        'color: #718893; font-weight: 300;'\n    );\n}\n\nfunction invalidateDependents(signal) {\n    if (DEBUG) {\n        console.log(\n            '%cSignal%c invalidate%c ' + signal.constructor.name + '#' + signal.id + (signal.name ? ' \"' + signal.name + '\"' : ''),\n            'color: #718893; font-weight: 300;',\n            'color: #3896BF; font-weight: 300;',\n            'color: #718893; font-weight: 300;'\n        );\n    }\n\n    let n = -1;\n    let dependent;\n    while (dependent = signal[++n]) {\n        signal[n] = undefined;\n        dependent.invalidate(signal);\n    }\n}\n\nexport function hasInput(signal, input) {\n    // Check if input exists in the -ve indexes\n    let n = 0;\n    while (signal[--n]) if (signal[n] === input) return true;\n}\n\n\n/**\nSignal\n\nA signal is an object that represents a value that may change. A signal has\nessentially one property, `.value`. A state signal can have its `.value`\nwritten, a compute signal's `.value` may only be read.\n\nThe `Signal` constructor is not called directly, but calling `Signal.of(value)`\ncreates a state signal, and `Signal.from(fn)` creates a compute signal.\n**/\n\nexport default class Signal {\n    /**\n    Signal.isSignal(object)\n\n    Returns `true` where `object` is an instance of `Signal`.\n\n    This guarantees that `object` has a gettable `value` property. This is not\n    true of an Observer, which is not really a signal at all – it cannot\n    have dependencies – but is only evaluated as one when invalidated.\n    **/\n\n    static isSignal(object) {\n        return object instanceof Signal;\n    }\n\n    /**\n    Signal.of()\n    Signal.of(value)\n\n    Creates a state signal that has essentially one property, `.value`.\n    When `.value` is set the signal becomes invalid, stale, out of date,\n    irrelevant, historic, old, and any signals that depend on it are invalidated.\n    **/\n\n    static of(value) {\n        return new ValueSignal(value);\n    }\n\n    /**\n    Signal.from(fn)\n    Signal.from(promise)\n    Signal.from(stream)\n\n    Creates a compute signal from a function, where `fn` computes a value by\n    reading other signals' values. This signal is then invalidated when any of\n    the read signals are invalidated.\n\n    Creates a state signal from a promise or stream that invalidates\n    dependencies as the promise or streams' values resolve.\n    **/\n\n    static from(fn, context) {\n        // Promise\n        if (fn.then) {\n            const signal = Signal.of();\n            fn.then((value) => signal.value = value);\n            return signal;\n        }\n\n        // Pipeable\n        if (fn.pipe) {\n            const signal = Signal.of();\n            fn.pipe({ push: (value) => signal.value = value });\n            return signal;\n        }\n\n        // Function\n        return new ComputeSignal(fn, context);\n    }\n\n    static compute(fn, context) {\n        return new ComputeSignal(fn, context);\n    }\n\n    static fromProperty(name, object) {\n        // Function\n        return new PropertySignal(name, object);\n    }\n\n    /**\n    Signal.frame(fn, initial)\n    Returns an observe signal, a form of compute signal that calls `fn` once\n    immediately, and then on every animation frame following the invalidation\n    of any signal read during the execution of `fn`.\n    **/\n\n    static frame(fn) {\n        // Add to signals called on invalidation\n        return new FrameObserver(fn);\n    }\n\n    /**\n    Signal.tick(fn, initial)\n    Returns an observe signal, a form of compute signal that calls `fn` once\n    immediately, and then on every tick following the invalidation of any signal\n    read during the execution of `fn`.\n    **/\n\n    static tick(fn) {\n        // Add to signals called on invalidation\n        return new TickObserver(fn);\n    }\n\n    /**\n    Signal.observe(signal, fn)\n    Calls `fn` on the next tick after `signal` changes.\n    **/\n\n    static observe(signal, fn) {\n        return new ObserveSignal(signal, fn);\n    }\n\n    /**\n    Signal.evaluate(object, fn[, context])\n\n    A function for building objects that behave as compute or observe signals.\n\n    Evaluates `object` as a signal by applying it to `fn` and returning the\n    result. Signals read during `fn()` have `object` registered as a dependent,\n    so `object.invalidate()` is called when any of those signals are invalidated.\n    It's the same function as that used internally to evaluate signals.\n\n    Typically `object.invalidate()` would cue a `Signal.evaluate(object, fn)` at\n    some point in the future. (It is ill-advised to `Signal.evaluate(object, fn)`\n    synchronously inside `.invalidate()`, although this should only lead to\n    wasted invalidations, not bad results, errm, in most cases, at least.)\n    **/\n\n    static evaluate(signal, fn, context = signal) {\n        // Make signal the evaluating signal for the duration of this\n        // synchronous evaluation of fn()\n        const previous = evaluatingSignal;\n        evaluatingSignal = signal;\n\n        if (DEBUG) console.group(\n            '%cSignal%c evaluate%c ' + evaluatingSignal.constructor.name + '#' + evaluatingSignal.id + (evaluatingSignal.name ? ' \"' + evaluatingSignal.name + '\"' : ''),\n            'color: #718893; font-weight: 300;',\n            'color: #3896BF; font-weight: 300;',\n            'color: #718893; font-weight: 300;'\n        );\n\n        const value = fn.apply(context);\n\n        if (window.DEBUG && window.DEBUG.signal !== false) console.groupEnd();\n\n        evaluatingSignal = previous;\n        return value;\n    }\n\n    /*\n    Signal.evaluating\n    The signal that is currently being evaluated, or undefined. This is exposed\n    so that Data() can make a better call about when to create signals (if there\n    is no evaluating signal, it needn't make a signal when a property is\n    accessed). Deliberately undocumented.\n    */\n\n    static get evaluating() {\n        return evaluatingSignal;\n    }\n\n    constructor(name) {\n        if (name) this.name = name;\n\n        if (DEBUG) {\n            this.id = ++id;\n            console.log(\n                '%cSignal%c create%c ' + this.constructor.name + '#' + this.id + (this.name ? ' \"' + this.name + '\"' : ''),\n                'color: #718893; font-weight: 300;',\n                'color: #3896BF; font-weight: 300;',\n                'color: #718893; font-weight: 300;'\n            );\n        }\n    }\n\n    /**\n    .valueOf()\n\n    Enables direct use in some expressions like addition or string concatenation.\n    This may prove to be less useful than we think. For one thing, logging a\n    signal object now evaluates it, affecting the outcome.\n    **/\n\n    valueOf() {\n        return this.value;\n    }\n\n    /*\n    .toString()\n    .toJSON()\n\n    Treat `.value` as the value to output?\n    */\n\n    toString() {\n        return this.value + '' ;\n    }\n\n    toJSON() {\n        return this.value;\n    }\n}\n\n\n/*\nValueSignal(value)\n*/\n\nclass ValueSignal extends Signal {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    /**\n    .value\n\n    Getting `.value` gets value from the cache.\n\n    Setting `.value`, assuming the newly set value differs from the previous\n    value, updates the cache and invalidates dependent signals.\n    **/\n\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal, irrespective of state of #value\n        if (evaluatingSignal) setDependency(this, evaluatingSignal);\n        return this.#value;\n    }\n\n    set value(value) {\n        // Don't update for no change in value\n        if(this.#value === value) return;\n\n        // Set cached value\n        this.#value = value;\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble but #valid is true and #value is set so\n        // that's ok I think?\n        invalidateDependents(this);\n    }\n}\n\n\n/*\nPropertySignal(value)\nWraps a property in a signal. TODO: is this really needed?\n*/\n\nclass PropertySignal extends Signal {\n    // Privates\n    #valid;\n    #value;\n\n    constructor(name, object) {\n        super(name);\n        this.object = object;\n    }\n\n    evaluate() {\n        return this.object[this.name];\n    }\n\n    /**\n    .value\n    Getting `.value` gets a cached value or, if the signal is invalid,\n    evaluates (and caches) value from `fn()`. During evaluation this signal is\n    registered as dependent on other signals whose value is got.\n    **/\n\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal, irrespective of state of #value\n        if (evaluatingSignal) setDependency(this, evaluatingSignal);\n        if (this.#valid) return this.#value;\n        this.#value = Signal.evaluate(this, this.evaluate, this);\n        this.#valid = true;\n        return this.#value;\n    }\n\n    set value(value) {\n        // Don't update for no change in value.\n        if(this.#value === value) return;\n\n        const { object, name } = this;\n\n        // Set value on object and update value from object in case target is\n        // doing something funky with property descriptors that return a\n        // different value from the value set.\n        object[name] = value;\n        value = object[name];\n\n        // Don't invalidate for no change in value.\n        if(this.#value === value) return;\n\n        // Set cache by reading value back off the object in case object is\n        // doing something funky with property descriptors that return a\n        // different value from the value that was set. Rare, but it can happen.\n        this.#value = value;\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble but #valid is true and #value is set so\n        // that's ok I think?\n        invalidateDependents(this);\n    }\n\n    /*\n    .invalidate(signal)\n    Invalidates this signal and calls `.invalidate(this)` on all dependent\n    signals. The `signal` parameter is the signal causing the invalidation; it\n    may be `undefined`: where it exists it is verified as a current input of\n    this before this is invalidated.\n    */\n\n    invalidate(signal) {\n        if (!this.#valid) return;\n\n        // Verify that signal has the right to invalidate this to protect us\n        // against the case where a dependent is left on another signal due to\n        // an old evaluation\n        if (signal && !hasInput(this, signal)) return;\n\n        this.#valid = false;\n\n        // Clear inputs\n        let n = 0;\n        while (this[--n]) this[n] = undefined;\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble, as it would evaluate and cache this signal\n        // and overwrite dependents before we have finished invalidating\n        // this set of dependents.\n        invalidateDependents(this);\n    }\n}\n\n\n/*\nComputeSignal(value)\n*/\n\nclass ComputeSignal extends Signal {\n    // Privates\n    #fn;\n    #context;\n    #valid;\n    #value;\n\n    constructor(fn, context) {\n        super();\n        this.#fn      = fn;\n        this.#context = context;\n    }\n\n    /**\n    .value\n    Getting `.value` gets a cached value or, if the signal is invalid,\n    evaluates (and caches) value from `fn()`. During evaluation this signal is\n    registered as dependent on other signals whose value is got.\n    **/\n\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal, irrespective of state of #value\n        if (evaluatingSignal) setDependency(this, evaluatingSignal);\n        if (this.#valid) return this.#value;\n        this.#value = Signal.evaluate(this, this.#fn, this.#context);\n        this.#valid = true;\n        return this.#value;\n    }\n\n    /*\n    .invalidate(signal)\n    Invalidates this signal and calls `.invalidate(this)` on all dependent\n    signals. The `signal` parameter is the signal causing the invalidation; it\n    may be `undefined`: where it exists it is verified as a current input of\n    this before this is invalidated.\n    */\n\n    invalidate(signal) {\n        if (!this.#valid) return;\n\n        // Verify that signal has the right to invalidate this to protect us\n        // against the case where a dependent is left on another signal due to\n        // an old evaluation\n        if (signal && !hasInput(this, signal)) return;\n\n        this.#valid = false;\n\n        // Clear inputs\n        let n = 0;\n        while (this[--n]) this[n] = undefined;\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble, as it would evaluate and cache this signal\n        // and overwrite dependents before we have finished invalidating\n        // this set of dependents.\n        invalidateDependents(this);\n    }\n}\n\n\n/*\nObserveSignal(signal, fn)\n*/\n\nexport class ObserveSignal {\n    constructor(signal, fn) {\n        this.signal = signal;\n        this.fn = () => fn(Signal.evaluate(this, this.evaluate, this));\n        this.fn();\n    }\n\n    evaluate() {\n        this.promise = undefined;\n        return this.signal.value;\n    }\n\n    invalidate(input) {\n        // If the observer is already cued do nothing\n        if (this.promise) return;\n\n        // Verify that input signal has the right to invalidate this\n        if (input && !hasInput(this, input)) return;\n\n        // Clear inputs\n        let n = 0;\n        while (this[--n]) this[n] = undefined;\n\n        // Evaluate and send value to consumer on next tick\n        this.promise = promise.then(this.fn);\n    }\n\n    stop() {\n        // Remove this from signal graph\n        let n = 0, input;\n        while (input = this[--n]) {\n            let m = -1;\n            removeOutput(input, this);\n            this[n] = undefined;\n        }\n\n        return this;\n    }\n}\n\n\n\n\n/*\nObserver(fn)\nAn Observer is a signal that calls `fn` on construction and again on every\ncue following an invalidation of any signal read by `fn`. Internal only,\nsub-classed by `TickObserver` and `FrameObserver`.\n*/\n\nexport class Observer {\n    constructor(fn) {\n        if (DEBUG) {\n            this.id   = ++id;\n            console.log(\n                '%cSignal%c create%c ' + this.constructor.name + '#' + this.id + (this.name ? ' \"' + this.name + '\"' : ''),\n                'color: #718893; font-weight: 300;',\n                'color: #3896BF; font-weight: 300;',\n                'color: #718893; font-weight: 300;'\n            );\n        }\n\n        // If no fn passed in we do not want to evaluate the signal immediately.\n        // This provides for a sub-class to define .evaluate() and launch it\n        // when it likes, as in Literal's Renderer.\n        if (!fn) return;\n\n        // Set fn as evaluation sunction\n        this.evaluate = fn;\n\n        // An initial, synchronous evaluation binds this observer to changes\n        Signal.evaluate(this, this.evaluate);\n    }\n\n    invalidate(input) {\n        // Verify that input signal has the right to invalidate this\n        if (input && !hasInput(this, input)) return;\n\n        // Static observers list\n        const observers = this.constructor.observers;\n\n        // If the observer is already cued do nothing\n        if (observers.indexOf(this) !== -1) return;\n\n        // Clear inputs\n        let n = 0;\n        while (this[--n]) this[n] = undefined;\n\n        this.cue();\n    }\n\n    stop() {\n        // Remove this from signal graph\n        let n = 0, input;\n        while (input = this[--n]) {\n            let m = -1;\n            removeOutput(input, this);\n            this[n] = undefined;\n        }\n\n        // Remove from observers if cued\n        const observers = this.constructor.observers;\n        const i = observers.indexOf(this);\n        if (i !== -1) observers.splice(i, 1);\n\n        return this;\n    }\n}\n\n\n/*\nTickObserver\nA TickObserver is a signal that calls `fn` on construction and again on every\ntick following an invalidation of any signal read by `fn`. Use `Signal.tick(fn)`.\n*/\n\nconst promise = Promise.resolve();\n\nfunction tick() {\n    const observers = TickObserver.observers;\n    let n = -1, signal;\n    while (signal = observers[++n]) Signal.evaluate(signal, signal.evaluate);\n    observers.length = 0;\n}\n\nexport class TickObserver extends Observer {\n    static observers = [];\n\n    cue() {\n        const observers = this.constructor.observers;\n\n        // If no observers are cued, cue tick() on the next tick\n        if (!observers.length) promise.then(tick);\n\n        // Add this observer to observers\n        observers.push(this);\n    }\n}\n\n\n/*\nFrameObserver\nA FrameObserver is a signal that calls `fn` on construction and again on every\nanimation frame following an invalidation of any signal read by `fn`. Use\n`Signal.frame(fn)`.\n*/\n\nfunction frame() {\n    const observers = FrameObserver.observers;\n    let n = -1, signal;\n    while (signal = observers[++n]) Signal.evaluate(signal, signal.evaluate);\n    observers.length = 0;\n}\n\nexport class FrameObserver extends Observer {\n    static observers = [];\n\n    cue() {\n        const observers = this.constructor.observers;\n\n        // If no observers are cued, cue tick() on the next tick\n        if (!observers.length) window.requestAnimationFrame(frame);\n\n        // Add this observer to observers\n        observers.push(this);\n    }\n}\n\n", "/**\nid(value)\nReturns `value`.\n**/\n\nexport default function id(value) { return value; }\n", "/**\noverload(fn, object)\n\nReturns an overloaded.\n\nTakes a `fn` that returns a string key, and an `object` of key:function\npairs. The returned function calls `fn` with all arguments to get a key,\nthen calls the function at `object[key]` with all arguments.\n\nWhere `fn` returns `undefined`, `object.default` is called if it is defined\nin `object`, otherwise `overload` throws a 'no function defined for key' error.\n\n```\nvar handleEvent = overload(get('type'), {\n    click:   (e) => {...},\n    input:   (e) => {...},\n    default: (e) => {...}\n});\n```\n*/\n\n\nexport default function overload(fn, map) {\n    return function overload() {\n        const key     = fn.apply(this, arguments);\n        const handler = (map[key] || map.default);\n\n        if (!handler) {\n            throw new Error('overload() no function defined for key \"' + key + '\"');\n        }\n\n        return handler.apply(this, arguments);\n    };\n}\n", "/**\nnoop()\nDoes nothing, returns undefined.\n**/\n\nexport default function noop() {}\n", "/**\nassign(node, properties)\n\nAssigns each property of `properties` to `node`, as a property where that\nproperty exists in `node`, otherwise as an attribute.\n\nIf `properties` has a property `'children'` it must be an array of nodes;\nthey are appended to 'node'.\n\nThe property `'html'` is aliased to `'innerHTML'`. The property `'text'`\nis aliased to `'textContent'`. The property `'tag'` is treated as an alias\nof `'tagName'` (which is ignored, as `node.tagName` is read-only). The\nproperty `'is'` is also ignored.\n*/\n\nimport curry from 'fn/curry.js';\nimport id from 'fn/id.js';\nimport noop from 'fn/noop.js';\nimport overload from 'fn/overload.js';\n\nconst assignProperty = overload(id, {\n\t// Ignore read-only properties or attributes\n\tis: noop,\n\ttag: noop,\n\n\tdata: function(name, node, object) {\n\t\t// Strip undefined\n\t\tfor (name in object) {\n\t\t\tif (object[name] === undefined) {\n\t\t\t\tdelete object[name];\n\t\t\t}\n\t\t}\n\t\t//console.log(Object.assign({}, object));\n\t\tObject.assign(node.dataset, object);\n\t},\n\n\tdataset: function(name, node, object) {\n\t\tObject.assign(node.dataset, object);\n\t},\n\n\thtml: function(name, node, content) {\n\t\tnode.innerHTML = content;\n\t},\n\n\ttext: function(name, node, content) {\n\t\tnode.textContent = content;\n\t},\n\n\tstyle: overload((name, node, content) => typeof content, {\n\t\tstring: (name, node, content) => node.style = content,\n\t\tobject: (name, node, content) => Object.assign(node.style, content)\n\t}),\n\n\tchildren: function(name, node, content) {\n\t\t// Empty the node and append children\n\t\tnode.innerHTML = '';\n\t\tnode.append.apply(node, content);\n\t},\n\n\t// SVG elements have a read-only properties, and must be set as string\n\t// attributes. Todo: explore the SVG property API to make these take\n\t// advantage of it\n\tpoints:    setAttribute,\n    cx:        setAttribute,\n    cy:        setAttribute,\n    r:         setAttribute,\n\tx:         setAttribute,\n\ty:         setAttribute,\n\tdx:        setAttribute,\n\tdy:        setAttribute,\n\ttransform: setAttribute,\n    preserveAspectRatio: setAttribute,\n    viewBox:   setAttribute,\n\n\tdefault: function(name, node, content) {\n\t\tif (name in node) {\n\t\t\tnode[name] = content;\n\t\t}\n\t\telse {\n\t\t\tnode.setAttribute(name, content);\n\t\t}\n\t}\n});\n\nfunction setAttribute(name, node, content) {\n\tnode.setAttribute(name, content);\n}\n\nexport function assign(node, attributes) {\n\tvar names = Object.keys(attributes);\n\tvar n = names.length;\n\n\twhile (n--) {\n\t\tassignProperty(names[n], node, attributes[names[n]]);\n\t}\n\n\treturn node;\n}\n\nexport default curry(assign, true);\n", "\nimport id       from 'fn/id.js';\nimport overload from 'fn/overload.js';\nimport assign   from './assign.js';\n\nconst svgNamespace = 'http://www.w3.org/2000/svg';\n\nconst template      = document.createElement('template');\nconst typeofContent = (type, content) => (content && typeof content);\n\n// Constructors\n\nfunction createContextFragment(context, html = '') {\n    const range = document.createRange();\n    range.selectNode(context);\n    return range.createContextualFragment(html);\n}\n\nconst createSVG = overload(typeofContent, {\n    string: function(tag, html) {\n        const node = document.createElementNS(svgNamespace, tag);\n        node.innerHTML = html;\n        return node;\n    },\n\n    object: function(tag, object) {\n        const node = document.createElementNS(svgNamespace, tag);\n\n        // Is it array-like?\n        if (typeof object.length === 'number') {\n            // Be careful here in case object is a live NodeList, which will\n            // mutate as you iterate over it. Applying object to .append()\n            // appears to not have this problem, and will work on arrays.\n            node.append.apply(node, object);\n        }\n        else {\n            assign(node, object);\n        }\n\n        return node;\n    },\n\n    default: (tag) => document.createElementNS(svgNamespace, tag)\n});\n\nconst createHTML = overload(typeofContent, {\n    string: function(tag, html) {\n        const node = document.createElement(tag);\n        node.innerHTML = html;\n        return node;\n    },\n\n    object: function(tag, object) {\n        const node = document.createElement(tag);\n\n        // Is it array-like?\n        if (typeof object.length === 'number') {\n            // Be careful here in case object is a live NodeList, which will\n            // mutate as you iterate over it. Applying object to .append()\n            // appears to not have this problem, and will work on arrays.\n            node.append.apply(node, object);\n        }\n        else {\n            assign(node, object);\n        }\n\n        return node;\n    },\n\n    default: (tag) => document.createElement(tag)\n});\n\n/**\ncreate(tag, content)\n\nConstructs and returns a new DOM node.\n\n- If `tag` is `\"text\"` a text node is created.\n- If `tag` is `\"fragment\"` a fragment is created.\n- If `tag` is `\"comment\"` a comment is created.\n- If `tag` is any other string the element `<tag></tag>` is created.\n\nWhere a comment or text node is created `content` must be a string, as is set as\ntextContent. For fragments and other nodes:\n\n- If `content` is a string it is set as innerHTML.\n- If `content` is array-like its items are appended to node. Note that where\n`content` is a NodeList, this removes nodes from whatever the NodeList belongs\nto.\n- If `content` is an object its properties are assigned as node properties or\nattributes.\n\n##### `create(tag, content, context)`\n\nWhere `tag` is `fragment` there is an optional third parameter `context`, which\nmust be an element. The fragment parser is run in the context of this element.\n\n```\ncreate('fragment', '<li>', create('ul'));\n```\n**/\n\nconst create = overload(id, {\n    comment: function(tag, text) {\n        return document.createComment(text || '');\n    },\n\n    fragment: overload(typeofContent, {\n        string: function(tag, html, context) {\n            if (context) {\n                return createContextFragment(context, html);\n            }\n\n            template.innerHTML = html;\n            return template.content.cloneNode(true);\n        },\n\n        object: function(tag, object, context) {\n            // If there is context, create a context-aware fragment\n            const fragment = context ?\n                createContextFragment(context) :\n                document.createDocumentFragment() ;\n\n            // Is object array-like?\n            if (typeof object.length === 'number') {\n                // Be careful here in case object is a live NodeList, which will\n                // mutate as you iterate over it. Applying object to .append()\n                // appears to not have this problem, and will work on arrays.\n                fragment.append.apply(fragment, object);\n            }\n            else {\n                assign(fragment, object);\n            }\n\n            return fragment;\n        },\n\n        default: () => document.createDocumentFragment()\n    }),\n\n    /*text: function (tag, text) {\n        return document.createTextNode(text || '');\n    },*/\n\n    circle:   createSVG,\n    ellipse:  createSVG,\n    g:        createSVG,\n    glyph:    createSVG,\n    image:    createSVG,\n    line:     createSVG,\n    rect:     createSVG,\n    use:      createSVG,\n    path:     createSVG,\n    pattern:  createSVG,\n    polygon:  createSVG,\n    polyline: createSVG,\n    svg:      createSVG,\n    tspan:    createSVG,\n    text:     createSVG,\n\n    default:  createHTML\n});\n\nexport default create;\n\n", "/**\ntoType(object)\nReturns `typeof object`.\n*/\n\nexport default (object) => typeof object;\n", "\n//import nothing    from '../nothing.js';\nimport noop       from '../noop.js';\nimport overload   from '../overload.js';\nimport toType     from '../to-type.js';\n\nconst assign     = Object.assign;\nconst create     = Object.create;\nconst $listeners = Symbol('done');\n\nconst call = overload(toType, {\n    function: (fn) => fn(),\n    object:   (object) => object.stop()\n});\n\nfunction throwTypeError(source) {\n    throw new TypeError('Stream cannot be created .from() ' + typeof source);\n}\n\nfunction push(stream, value) {\n    if (value === undefined) return;\n    let n = -1;\n    while (stream[++n]) stream[n].push(value);\n}\n\nfunction stop(stream) {\n    // Set status\n    stream.status = 'done';\n\n    // Call done functions and listeners\n    const listeners = stream[$listeners];\n    stream[$listeners] = undefined;\n\n    if (listeners) listeners.forEach(call);\n\n    // Loop through outputs, propagate stop() down the pipe\n    let o = -1, output;\n    while (output = stream[++o]) {\n        // Remove output from this\n        stream[o] = undefined;\n        // Remove this from output's inputs\n        removeInput(output, stream);\n        // If output has no inputs left, stop it\n        if (!output[-1]) output.stop();\n    }\n\n    return stream;\n}\n\nfunction removeInput(stream, input) {\n    // Remove input from stream\n    let i = 0;\n    while (stream[--i] && stream[i] !== input);\n    while (stream[i--]) stream[i + 1] = stream[i];\n}\n\nfunction removeOutput(stream, output) {\n    // Remove output from stream\n    let o = -1;\n    while (stream[++o] && stream[o] !== output);\n    while (stream[o++]) stream[o - 1] = stream[o];\n}\n\nfunction unpipe(output, input) {\n    // Remove link between streams without stopping them\n    removeInput(input, output);\n    removeOutput(output, input);\n}\n\n\n/* Consumer() */\n\nfunction Consumer(fn) {\n    this.push = fn;\n}\n\nassign(Consumer.prototype, {\n    /**\n    .start()\n    The `.start()` method is provided as a way to build timed streams. It echoes\n    its arguments to the stream head `.start()`, so the head determines whether\n    the stream starts immediately or asynchronously.\n    **/\n    start: function() {\n        if (this.status === 'done') return this;\n\n        // Loop through inputs\n        let i = 0, input;\n        while (input = this[--i]) {\n            // Loop through input's outputs\n            let o = -1;\n            while (input[++o]) if (input[o] === this) break;\n            input[o] = this;\n            /* If we don't qualify this, all producers must have a start method\n               SHOULD WE DO THAT?*/\n            if (input.start) input.start.apply(input, arguments);\n        }\n\n        return this;\n    },\n\n    /**\n    .stop()\n    Stops the stream, passing any parameters up to the head of the stream. The\n    head determines whether the stream stops immediately or asynchronously.\n    **/\n    stop: function() {\n        if (this.status === 'done') return this;\n\n        // Loop through inputs, track inputs that this stop depends on\n        let input;\n        while (input = this[-1]) {\n            // Remove input from this\n            let i = -1;\n            while (this[i--]) this[i + 1] = this[i];\n\n            // Input is not a stoppable (I don't think this should happen?).\n            if (!input.stop) {console.log('This shouldn\\'t happen?');continue;}\n\n            // If input has no other outputs, stop it\n            if (!input[1]) {\n                // Call .stop() and quit the process to wait until input calls\n                // .stop() on this once again – which may happen synchronously\n                // or asynchronously\n                input.stop.apply(input, arguments);\n                return this;\n            }\n\n            // Input has more than one output, remove this from input's outputs\n            removeOutput(input, this);\n        }\n\n        return stop(this);\n    },\n\n    /**\n    .done(fn)\n    Cues `fn` to be called when the stream is stopped.\n    **/\n    done: function(listener) {\n        // Is stream already stopped? Call listener immediately.\n        if (this.status === 'done') {\n            call(listener);\n            return this;\n        }\n\n        const listeners = this[$listeners] || (this[$listeners] = []);\n        listeners.push(listener);\n        return this;\n    }\n});\n\n\n/* Reduce() */\n\nfunction Reduce(fn, accumulator) {\n    this.fn    = fn;\n    this.value = accumulator;\n    this.i     = 0;\n}\n\nReduce.prototype = assign(create(Consumer.prototype), {\n    push: function(value) {\n        const fn = this.fn;\n        this.value = fn(this.value, value, this.i++, this);\n    }\n});\n\n\n/**\nStream(start)\nCreates a stream from a `start` function, called when a consumer is first\nattached, with two arguments, `start(push, stop)`. `push(value)` is called to\nwrite `value` to the stream and `stop()` is called to stop the stream.\n**/\n\nexport default function Stream(fn) {\n    if (typeof fn === 'function') {\n        this.start = function() {\n            const pushFn = (value) => push(this, value);\n            const stopFn = (...args) => this.stop.apply(this, args);\n            fn(pushFn, stopFn, ...arguments);\n            return this;\n        };\n    }\n    else {\n        throw new TypeError('new Stream() cannot be created from ' + typeof fn);\n    }\n}\n\nassign(Stream.prototype, Consumer.prototype, {\n    /**\n    .pipe(stream)\n    Starts a stream and pushes its values into `stream`. Returns `stream`.\n    **/\n    pipe: function(output) {\n        // If output is stoppable set this as its input\n        if (output.stop) {\n            // Guard against this piping twice to output\n            let i = 0;\n            while (output[--i]) if (output[i] === this) break;\n            output[i] = this;\n\n            // if output is a cold pipeable go no further\n            if (output.pipe && !output[0]) return output;\n        }\n\n        // It must be a consumer (or a hot pipeable), start this immediately\n        let o = -1;\n        while (this[++o]) if (this[o] === output) break;\n        this[o] = output;\n        this.start();\n\n        // Return output\n        return output;\n    },\n\n    /**\n    .each(fn)\n    Consumer the stream, calling `fn(value)` for each value in it.\n    Returns the stream.\n    **/\n    each: function(fn) {\n        // Start the consumer immediately\n        return this.pipe(new Consumer(fn));\n    },\n\n    /**\n    .buffer(...values)\n    Inserts a buffer of values into the start of a stream. Although the buffer\n    is not hot, before it is started .push() may be used to add values to the\n    buffer.\n    **/\n    buffer: function(...values) {\n        return this.pipe(new Buffer(values));\n    },\n\n    /**\n    .filter(fn)\n    Filters out values where `fn(value)` is falsy.\n    **/\n    filter: function(fn) {\n        return this.pipe(new Filter(fn));\n    },\n\n    /**\n    .flatMap(fn)\n    **/\n    flatMap: function(fn) {\n        return this.pipe(new FlatMap(fn));\n    },\n\n    /**\n    .map(fn)\n    Maps each value in a stream to `fn(value)` and pipes non-`undefined` results\n    downstream.\n    **/\n    map: function(fn) {\n        return this.pipe(new Map(fn));\n    },\n\n    /**\n    .reduce(fn, initial)\n    Consumer the stream, calling `fn(accumulator, value)` for each value in it.\n    Returns the accumulator.\n    **/\n    reduce: function(fn, accumulator) {\n        return this.pipe(new Reduce(fn, accumulator)).start().value;\n    },\n\n    /**\n    .scan(fn, initial)\n    Calls `fn(current, value)` for each `value` in the stream. Where `fn`\n    returns a value it is pushed downstream, and `current` assumes that value\n    on the next iteration. Where `fn` returns `undefined` nothing is pushed and\n    `current` remains unchanged.\n    **/\n    scan: function(fn, initial) {\n        return this.pipe(new Scan(fn, initial));\n    },\n\n    /**\n    .slice(n, m)\n    Returns a stream of the nth to mth values of stream.\n    **/\n    slice: function(n, m) {\n        return this.pipe(new Slice(n, m));\n    },\n\n    /**\n    .split(n)\n    **/\n    split: function(n) {\n        return this.pipe(new Split(n));\n    },\n\n    /* Experimental async iterator support for `for await (x of stream)`\n       loops. */\n    [Symbol.asyncIterator]: async function*() {\n        // Buffer for synchronous values\n        const values = [];\n        let push = (value) => values.push(value);\n\n        function setResolve(res, rej) {\n            push = res;\n        }\n\n        this\n        .each((value) => push(value))\n        .done(() => push = noop);\n\n        while (push !== noop) {\n            yield values.length ?\n                // Yield collected synchronous value\n                values.shift() :\n                // Yield next asynchronous value\n                await new Promise(setResolve) ;\n        }\n    }\n});\n\n\n/**\nPromiseStream(promise)\n**/\n\nfunction PromiseStream(promise) {\n    this.promise = promise;\n}\n\nPromiseStream.prototype = assign(create(Stream.prototype), {\n    start: function() {\n        this.promise\n        .then((value) => push(this, value))\n        .finally(() => this.stop());\n        return this;\n    }\n});\n\n\n/*\nBuffer(values)\nA Buffer stream may be pushed to before it is piped, as it starts life with an\narray buffer of values.\n*/\n\nfunction Buffer(values) {\n    this.values = values || [];\n}\n\nBuffer.prototype = assign(create(Stream.prototype), {\n    start: function() {\n        const values = this.values;\n\n        if (!values) return Stream.prototype.start.apply(this);\n\n        // Loop over values\n        let n = -1;\n        while(n++ < values.length) {\n            // Push values to stream\n            push(this, values[n]);\n\n            // If stream was stopped as a result of a push, don't continue pushing\n            if (this.status === 'done') return this;\n        }\n\n        // Throw away values buffer\n        this.values = undefined;\n\n        // Start streams that are piped to this buffer stream\n        return Stream.prototype.start.apply(this);\n    },\n\n    push: function(value) {\n        return this.values ?\n            this.values.push(value) :\n            push(this, value) ;\n    }\n});\n\n\n/* Filter() */\n\nfunction Filter(fn) {\n    this.fn = fn;\n}\n\nFilter.prototype = assign(create(Stream.prototype), {\n    push: function filter(value) {\n        const fn = this.fn;\n        return fn(value) && push(this, value);\n    }\n});\n\n\n/* FlatMap() */\n\nfunction FlatMap(fn) {\n    this.fn = fn;\n}\n\nFlatMap.prototype = assign(create(Stream.prototype), {\n    push: function flatMap(value) {\n        const fn     = this.fn;\n        const values = fn(value);\n\n        if (values === undefined) { return; }\n\n        // Flatten array or array-like\n        if (isIterable(values)) {\n            for (const value of values) {\n                push(this, value);\n            }\n        }\n        // Flatten stream\n        else if (values.pipe) {\n            console.warn('FlatMapping pipeables is dodgy. Map to arrays for the moment please.');\n            // Todo: support flattening of streams. This method is crude -\n            // it does not preserve order, for one thing. Should streams be\n            // made iterable? CAN streams be made iterable? They'd have to\n            // be async...\n            this.done(values.each((value) => push(this, value)));\n            // This causes problems if you try\n            // stream.scan(...).flatMap(...)\n            //values.pipe(this[0]);\n        }\n        // Flatten promise\n        else if (values.then) {\n            values.then((value) => push(this, value));\n        }\n    }\n});\n\n\n/* Map() */\n\nfunction Map(fn) {\n    this.fn = fn;\n}\n\nMap.prototype = assign(create(Stream.prototype), {\n    push: function map(value) {\n        const fn     = this.fn;\n        const result = fn(value);\n        // Reject undefined\n        return result !== undefined && push(this, result);\n    }\n});\n\n\n/*\nMerge()\n*/\n\nfunction Merge(inputs) {\n    this.inputs = inputs;\n}\n\nMerge.prototype = assign(create(Stream.prototype), {\n    push: function(value) {\n        return push(this, value);\n    },\n\n    pipe: function(output) {\n        let n = -1, input;\n        while (input = this.inputs[++n]) {\n            if (input.pipe) input.pipe(this) ;\n            else Stream.from(input).pipe(this) ;\n        }\n\n        return Stream.prototype.pipe.call(this, output)\n    }\n});\n\n\n/* Scan() */\n\nfunction Scan(fn, accumulator) {\n    this.fn    = fn;\n    this.value = accumulator;\n}\n\nScan.prototype = assign(create(Stream.prototype), {\n    push: function(value) {\n        const fn = this.fn;\n        this.value = fn(this.value, value);\n        push(this, this.value);\n    }\n});\n\n\n/* Slice() */\n\nfunction Slice(n, m = Infinity) {\n    if (window.DEBUG && (typeof n !== 'number' || n < 0)) {\n        throw new Error('Stream: .slice() requires a positive integer (' + n + ')');\n    }\n\n    if (window.DEBUG && (typeof m !== 'number' || m < 1)) {\n        throw new Error('Stream: .slice() requires a non-zero positive integer (n, ' + n + ')');\n    }\n\n    this.index    = -n;\n    this.indexEnd = n + m;\n}\n\nSlice.prototype = assign(create(Stream.prototype), {\n    push: function take(value) {\n        if (++this.index > 0) {\n            push(this, value);\n        }\n\n        if (this.index === this.indexEnd) {\n            this.stop();\n        }\n    }\n});\n\n\n/* Split(input, fn) */\n\nfunction Split(fn) {\n    this.chunk = [];\n\n    if (typeof fn === 'number') this.n = fn;\n    else this.fn = fn;\n}\n\nSplit.prototype = assign(create(Stream.prototype), {\n    fn: function() {\n        return this.chunk.length === this.n;\n    },\n\n    push: function map(value) {\n        const chunk = this.chunk;\n\n        if (this.fn(value)) {\n            // Emit complete chunk and create a new chunk\n            push(this, chunk);\n            this.chunk = [];\n        }\n        else {\n            // Push to existing chunk\n            chunk.push(value);\n        }\n    }\n});\n\n\nassign(Stream, {\n    from: overload(toType, {\n        /**\n        Stream.from(fn)\n        Create a pushable map stream from function `fn`.\n        **/\n        function: (fn) => new Map(fn),\n\n        object: (object) =>\n            /**\n            Stream.from(stream)\n            Create a read-only stream from a producer, an object with a\n            `.pipe()` method. ???\n            **/\n            typeof object.pipe === 'function' ? object.pipe(Stream.of()) :\n\n            /**\n            Stream.from(promise)\n            Create a read-only stream from a promise. The stream is stopped when\n            the promise resolves or rejects.\n            **/\n            typeof object.then === 'function' ? new PromiseStream(object) :\n\n            /**\n            Stream.from(array)\n            Create a pushable buffer stream from an array or array-like object.\n            **/\n            typeof object.length === 'number' ? new Buffer(Array.from(object)) :\n\n            // object cannot be made into stream\n            throwTypeError(object)\n    }),\n\n    /**\n    Stream.of(...values)\n    Create a pushable buffer stream from parameter values.\n    **/\n    of: (...values) => new Buffer(values),\n\n    /**\n    Stream.merge(stream1, stream2, ...)\n    Creates a stream by merging values from any number of input streams into a\n    single output stream. Values are emitted in the time order they are received\n    from inputs.\n\n    ```js\n    Stream.merge(stream1, stream2).each((value) => {\n        // value is from stream1 or stream 2\n    });\n    ```\n    **/\n    merge: (...inputs) =>  new Merge(inputs),\n\n    /**\n    Stream.push(stream, value)\n    Pushes `value` to `stream`'s outputs (even on streams that have no `.push()`\n    method). For use in sub-classing Stream.\n    **/\n    push,\n\n    /**\n    Stream.stop(stream)\n    Stops stream, calling `.done()` handlers, setting status to `'done'` and\n    stopping dependent streams. For internal use when sub-classing Stream.\n    **/\n    stop,\n\n    /*\n    Stream.input(stream, output)\n    Remove output stream from `stream` and vice-versa, without stopping either\n    stream. Normally `stream.stop()` should be used to stop the flow of a pipe -\n    this function is used when making dynamic graphs of streams that need to\n    stay alive.\n    */\n    unpipe,\n\n    Each: Consumer\n});\n", "\n/**\nevents(type, element)\n\nReturns a mappable stream of events heard on `element`.\n\n```js\nevents('click', element)\n.map((e) => e.target.id)\n```\n\nThe first parameter may alternatively be a select object. It must have a\n`.type` property.\n\n```js\nevents({ type: 'click' }, element)\n.map((e) => e.target.id)\n```\n\nThe object may contain a number of other properties that select the events\nreceived. It supports the standard addEventListener options, for passive and\ncapture phase event binding.\n\n```js\nevents({ type: 'scroll', passive: true, capture true }, window)\n.map((e) => window.scrollTop)\n```\n\nAnd a `.select` property, a CSS selector, that filters events to those with\ntargets that match or have a `closest()` ancestor that matches the selector.\n\n```js\nevents({ type: 'click', select: '[name=\"button\"]' }, element)\n.map((e) => e.target.id)\n```\n\nHowever, if you need to delegate events it is recommended to use the\n`delegate()` function, which has the added benefit of direct access to the\ndelegated target.\n\n```js\nevents('click', element)\n.each(delegate({\n    '[name=\"button\"]': (target, e) => console.log(target.id),\n    '[name=\"remove\"]': (target, e) => document.getElementById(target.value).remove(),\n    ...\n}))\n```\n\nStopping an event stream removes its event listeners.\n\n```js\nevents('click', element).stop()\n```\n**/\n\n/*\nevents(type, element, initial)\n\nPass in an `initial` event object to have the event stream start synchronously\nwith an initial value when consumed.\n*/\n\nimport cache  from 'fn/cache.js';\nimport Stream from 'fn/stream/stream.js';\n\nconst assign  = Object.assign;\nconst rspaces = /\\s+/;\nconst types   = {\n    fullscreenchange: cache(() => (\n        'fullscreenElement' in document ? 'fullscreenchange' :\n        'webkitFullscreenElement' in document ? 'webkitfullscreenchange' :\n        'mozFullScreenElement' in document ? 'mozfullscreenchange' :\n        'msFullscreenElement' in document ? 'MSFullscreenChange' :\n        'fullscreenchange'\n    ))\n};\n\n\n// DOM click events may be simulated on inputs when their labels are\n// clicked. The tell-tale is they have the same timeStamp. Track click\n// timeStamps.\nvar clickTimeStamp = 0;\n\nwindow.addEventListener('click', (e) => clickTimeStamp = e.timeStamp);\n\nfunction listen(listener, type) {\n    listener.node.addEventListener(types[type] ? types[type]() : type, listener, listener.options);\n    return listener;\n}\n\nfunction unlisten(listener, type) {\n    listener.node.removeEventListener(types[type] ? types[type]() : type, listener);\n    return listener;\n}\n\nfunction Events(type, options, node, initialEvent) {\n    // Potential hard-to-find error here if type has repeats, ie 'click click'.\n    // Lets assume nobody is dumb enough to do this, I dont want to have to\n    // check for that every time.\n    this.types        = type.split(rspaces);\n    this.options      = options;\n    this.node         = node;\n    this.select       = options && options.select;\n    this.initialEvent = initialEvent;\n}\n\nassign(Events.prototype, Stream.prototype, {\n    start: function() {\n        this.types.reduce(listen, this);\n\n        if (this.initialEvent) {\n            this.handleEvent(this.initialEvent);\n            delete this.initialEvent;\n        };\n\n        return this;\n    },\n\n    handleEvent: function(e) {\n        // Ignore clicks with the same timeStamp as previous clicks –\n        // they are likely simulated by the browser, like how clicks on labels\n        // cause simulated clicks to be emitted from inputs\n        if (e.type === 'click' && e.timeStamp <= clickTimeStamp) return;\n\n        // If there is a selector and the target doesn't match, shoofty\n        // outta here\n        if (this.select) {\n            const selectedTarget = e.target.closest(this.select);\n            if (!selectedTarget) { return; }\n            e.selectedTarget = selectedTarget;\n        }\n\n        Stream.push(this, e);\n    },\n\n    stop: function() {\n        this.types.reduce(unlisten, this);\n        return Stream.prototype.stop.apply(this);\n    }\n});\n\nexport default function events(type, node, initialEvent) {\n    let options;\n\n    if (typeof type === 'object') {\n        options = type;\n        type    = options.type;\n    }\n\n    return new Events(type, options, node, initialEvent);\n}\n", "\n/**\nisPrimaryButton(e)\nReturns `true` if event is from the primary (normally the left or only)\nbutton of an input device. Use this to filter out right-clicks.\n*/\n\nexport default function isPrimaryButton(e) {\n    // Ignore mousedowns on any button other than the left (or primary)\n    // mouse button, or when a modifier key is pressed.\n    return (e.which === 1 && !e.ctrlKey && !e.altKey && !e.shiftKey);\n}\n", "import curry from './curry.js';\n\n/**\nparseValue(units, string)\n\nParse `string` as a value with a unit (such as `\"3px\"`). Parameter `units` is an\nobject of functions keyed by the unit postfix. It may also have a `catch`\nfunction.\n\n```js=\nconst parseUnitValue = parseValue({\n    px: function(n) {\n        return n;\n    },\n\n    catch: function(string) {\n        throw new Error('Cannot parse px value');\n    }\n});\n```\n**/\n\n// Be generous in what we accept, space-wise, but exclude spaces between the\n// number and the unit\nconst runit = /^\\s*([+-]?\\d*\\.?\\d+)([^\\s]*)\\s*$/;\n\nexport default function parseValue(units) {\n    return function parseValue(string) {\n        // Allow number to pass through\n        if (typeof string === 'number') {\n            return string;\n        }\n\n        var entry = runit.exec(string);\n\n        if (!entry || !units[entry[2] || '']) {\n            if (!units.catch) {\n                throw new Error('Cannot parse value \"' + string + '\" (accepted units ' + Object.keys(units).join(', ') + ')');\n            }\n\n            return entry ?\n                units.catch(parseFloat(entry[1]), entry[2]) :\n                units.catch(parseFloat(string)) ;\n        }\n\n        return units[entry[2] || ''](parseFloat(entry[1]));\n    };\n}\n", "\n/**\ntoRad(deg)\n**/\n\nexport default (n) => n * Math.PI / 180;\n", "\nimport id         from './id.js';\nimport parseValue from './parse-value.js';\nimport toRad      from './to-rad.js';\n\n/**\nparseAngle(string)\nParses strings of the form `'45deg'`, `'0rad'` or `'0.5turn'`. Returns a\nnumber in radians. If `string` is a number, it passes through.\n**/\n\nexport default parseValue({\n    deg:  toRad,\n    rad:  id,\n    turn: (n) => n * 2 * Math.PI,\n    catch: function(string) {\n        throw new Error('Cannot parse value \"' + string + '\"');\n    }\n});\n", "/**\nstyle(property, node)\n\nReturns the computed style `property` of `node`.\n    style('transform', node);  // returns transform\n*/\n\nimport parseAngle from 'fn/parse-angle.js';\n\nvar rpx    = /px$/;\nvar rangle = /deg$|turn$|rad$/;\n\nfunction computedStyle(name, node) {\n\treturn window.getComputedStyle ?\n\t\twindow\n\t\t.getComputedStyle(node, null)\n\t\t.getPropertyValue(name) :\n\t\t0 ;\n}\n\nexport default function style(name, node) {\n    var value = computedStyle(name, node);\n\n    // Pixel values are converted to number type\n    return typeof value === 'string' ?\n\t\trpx.test(value) ? parseFloat(value) :\n\t\trangle.test(value) ? parseAngle(value) :\n        value :\n\t\tvalue ;\n}\n", "// Units\n\nimport id         from 'fn/id.js';\nimport overload   from 'fn/overload.js';\nimport toType     from 'fn/to-type.js';\nimport parseValue from 'fn/parse-value.js';\nimport style      from './style.js';\n\n\n/* Track document font size */\n\nlet emSize;\nlet remSize;\n\nfunction getEmSize() {\n    if (!emSize) {\n        if (window.DEBUG) {\n            console.warn('Calculating root em value may cause reflow as user font-size cannot be known without setting <html style=\"font-size: 100%;\">');\n        }\n\n        const styledFontSize = document.documentElement.style.fontSize;\n        document.documentElement.style.fontSize = '100%';\n        emSize = style(\"font-size\", document.documentElement);\n        document.documentElement.style.fontSize = styledFontSize || '';\n    }\n\n    return emSize;\n}\n\nfunction getRemSize() {\n    if (!remSize) {\n        remSize = style(\"font-size\", document.documentElement);\n    }\n\n    return remSize;\n}\n\nwindow.addEventListener('resize', () => {\n    emSize  = undefined;\n    remSize = undefined;\n});\n\n/**\npx(value)\nTakes a number in pixels or a string of the form `'10px'`, `'10em'`, `'10rem'`,\n`'100vw'`, `'100vh'`, `'100vmin'` or `'100vmax'`, and returns a numeric value\nin pixels.\n*/\n\nexport const px = overload(toType, {\n    'number': id,\n\n    'string': parseValue({\n        px:   id,\n        em:   (n) => getEmSize() * n,\n        rem:  (n) => getRemSize() * n,\n        vw:   (n) => window.innerWidth * n / 100,\n        vh:   (n) => window.innerHeight * n / 100,\n\n        vmin: (n) => (\n            window.innerWidth < window.innerHeight ?\n                window.innerWidth * n / 100 :\n                window.innerHeight * n / 100\n        ),\n\n        vmax: (n) => (\n            window.innerWidth < window.innerHeight ?\n                window.innerHeight * n / 100 :\n                window.innerWidth * n / 100\n        )\n    })\n});\n\nexport default px;\n\n/**\nem(value)\nTakes numeric value in px, or CSS length of the form `'10px'`, and returns\na numeric value in `em`, eg. `0.625`. Depends on the user defined browser\n`font-size`.\n*/\n\nexport function em(n) {\n    return px(n) / getEmSize();\n}\n\n/**\nrem(value)\nTakes numeric value in px, or CSS length of the form `'10px'`, and returns\na numeric value in `rem`, eg. `0.625`. Depends on the `font-size` of the\ndocumentElement.\n*/\n\nexport function rem(n) {\n    return px(n) / getRemSize();\n}\n\n/**\nvw(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vw`, eg. `120`. Depends on the width of the viewport at\nrender time.\n*/\n\nexport function vw(n) {\n    return 100 * px(n) / window.innerWidth;\n}\n\n/**\nvh(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vh`, eg. `120`. Depends on the height of the viewport at\nrender time.\n*/\n\nexport function vh(n) {\n    return 100 * px(n) / window.innerHeight;\n}\n\n/**\nvmin(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vmin`, eg. `120`. Depends on the minimum dimension of the\nviewport at render time.\n*/\n\nexport function vmin(n) {\n    return 100 * px(n) / (\n        window.innerWidth < window.innerHeight ?\n            window.innerWidth :\n            window.innerHeight\n    );\n}\n\n/**\nvmax(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vmax`, eg. `120`. Depends on the maximum dimension of the\nviewport at render time.\n*/\n\nexport function vmax(n) {\n    return 100 * px(n) / (\n        window.innerWidth < window.innerHeight ?\n            window.innerHeight :\n            window.innerWidth\n    );\n}\n", "\n/**\ntrigger(type, node)\n\nTriggers event of `type` on `node`. Returns `false` if the event default was\nprevented, otherwise `true`.\n\n```\ntrigger('activate', node);\n```\n\nAlternatively the first argument may be an object with a `type` property, and\noptionally `detail`, which must be an object, and `bubbles`, `cancelable` and\n`composed` options, which determine the behaviour of the event.\n\n```\ntrigger({\n    type:       'activate',\n    detail:     {...},\n    bubbles:    true,\n    cancelable: true,\n    composed:   false\n}, node);\n```\n**/\n\nimport curry from 'fn/curry.js';\n\nconst assign   = Object.assign;\n\nconst defaults = {\n    // The event bubbles (false by default)\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n    bubbles: true,\n\n    // The event may be cancelled (false by default)\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n    cancelable: true\n\n    // Trigger listeners outside of a shadow root (false by default)\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event/composed\n    //composed: false\n};\n\nexport function trigger(type, node) {\n    let options = defaults;\n    let properties, detail, bubbles, cancelable, composed, event;\n\n    if (typeof type === 'object') {\n        ({ type, detail, bubbles, cancelable, composed, ...properties } = type);\n\n        // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n        // Options accepted by CustomEvent:\n        // detail:     any\n        // bubbles:    true | false\n        // cancelable: true | false\n        // composed:   true | false\n        event = assign(new CustomEvent(type, {\n            detail,\n            bubbles:    bubbles    || defaults.bubbles,\n            cancelable: cancelable || defaults.cancelable,\n            composed:   composed   || defaults.composed\n        }), properties);\n    }\n    else {\n        event = new CustomEvent(type, defaults);\n    }\n\n    return node.dispatchEvent(event);\n}\n\nexport default curry(trigger, true);\n", "\n/**\nexec(regex, fn, string)\nCalls `fn` with the result of `regex.exec(string)` if that result is not null,\nand returns the resulting value.\n**/\n\nimport curry from './curry.js';\n\nexport function exec(regex, fn, string) {\n    let data;\n\n    // If string looks like a regex result, get rest of string\n    // from latest index\n    if (typeof string !== 'string' && string.input !== undefined && string.index !== undefined) {\n        data = string;\n        string = data.input.slice(\n            string.index\n            + string[0].length\n            + (string.consumed || 0)\n        );\n    }\n\n    // Look for tokens\n    const tokens = regex.exec(string);\n    if (!tokens) { return; }\n\n    const output = fn(tokens);\n\n    // If we have a parent tokens object update its consumed count\n    if (data) {\n        data.consumed = (data.consumed || 0)\n            + tokens.index\n            + tokens[0].length\n            + (tokens.consumed || 0) ;\n    }\n\n    return output;\n}\n\nexport default curry(exec, true);\n", "\nimport curry from './curry.js';\nimport { exec } from './exec.js';\n\nfunction error(regex, reducers, string) {\n    if (string.input !== undefined && string.index !== undefined) {\n        string = string.input;\n    }\n\n    throw new Error('Cannot parse string \"' + (string.length > 128 ? string.length.slice(0, 128) + '…' : string) + '\"');\n}\n\nfunction reduce(reducers, acc, tokens) {\n    let n = -1;\n\n    while (++n < tokens.length) {\n        acc = (tokens[n] !== undefined && reducers[n]) ? reducers[n](acc, tokens) : acc ;\n    }\n\n    // Call the optional done fn\n    return reducers.done ? reducers.done(acc, tokens) :\n        // Support the old .close() name\n        reducers.close ? reducers.close(acc, tokens) :\n        // Return the result\n        acc ;\n}\n\n/**\ncapture(regex, reducers, accumulator, string)\nParse `string` with `regex`, calling functions in `reducers` to modify\nand return `accumulator`.\n\nReducers is an object of functions keyed by the index of their capturing\ngroup in the regexp result (`0` corresponding to the entire regex match,\nthe first capturing group being at index `1`). Reducer functions are\ncalled in capture order for all capturing groups that captured something.\nReducers may also define the function 'done', which is called at the end\nof every capture. All reducer functions are passed the paremeters\n`(accumulator, tokens)`, where `tokens` is the regexp result, and are expected\nto return a value that is passed as an accumulator to the next reducer function.\n\nReducers may also define a function `'catch'`, which is called when a match\nhas not been made (where `'catch'` is not defined an error is thrown).\n\n```js\nconst parseValue = capture(/^\\s*(-?\\d*\\.?\\d+)(\\w+)?\\s*$/, {\n    // Create a new accumulator object each call\n    0: () => ({}),\n\n    1: (acc, tokens) => {\n        acc.number = parseFloat(tokens[1]);\n        return acc;\n    },\n\n    2: (acc, tokens) => {\n        acc.unit = tokens[2];\n        return acc;\n    }\n}, null);\n\nconst value = parseValue('36rem');    // { number: 36, unit: 'rem' }\n```\n*/\n\nexport function capture(regex, reducers, acc, string) {\n    const output = exec(regex, (tokens) => reduce(reducers, acc, tokens), string);\n\n    // If tokens is undefined exec has failed to apply regex to string\n    return output === undefined ?\n        // If there is a catch function, call it, otherwise error out\n        reducers.catch ?\n            reducers.catch(acc, string) :\n            error(regex, reducers, string) :\n\n        // Return the accumulator\n        output ;\n}\n\nexport default curry(capture, true);\n", "\n\nimport create from '../create.js';\n\nconst $internals = Symbol('internals');\n\n// TODO: No longer needed polyfill for Safari... ??\n/*\nfunction attachInternals(element) {\n    var internals;\n\n    // Use native attachInternals where it exists and we have the right to use\n    // it - you cannot attachInternals to customised built-ins\n    if (element.attachInternals && !element.getAttribute('is')) {\n        return element.attachInternals();\n        //if (internals.setFormValue) return internals;\n    }\n    else {\n        internals = {\n            shadowRoot: elem.shadowRoot\n        };\n    }\n\n    // Otherwise polyfill it with a pseudo internals object, actually a hidden\n    // input that we put inside element (but outside the shadow DOM). We may\n    // not yet put this in the DOM however – it violates the spec to give a\n    // custom element children before it's contents are parsed. Instead we\n    // wait until connectCallback.\n    //internals.polyfillInput = create('input', { type: 'hidden', name: elem.name });\n    //elem.appendChild(internals.polyfillInput);\n    // Polyfill internals object setFormValue\n    //internals.setFormValue = function(value) {\n    //    this.input.value = value;\n    //};\n\n    return internals;\n}\n\nexport function createInternals(Element, element, shadow) {\n    return (element[$internals] = Element.formAssociated ?\n        attachInternals(element) :\n        { shadowRoot: shadow }\n    );\n}\n*/\n\nexport function createInternals(Element, element, shadow) {\n    return element[$internals] = (element.attachInternals && !element.getAttribute('is')) ?\n        element.attachInternals() :\n        { shadowRoot: shadow } ;\n}\n\nexport function getInternals(element) {\n    return element[$internals];\n}\n", "\n/**\nelement(tag, lifecycle, properties, stylesheet, message)\n\nRegisters a custom element `tag` and returns its constructor.\n\n- `tag`: A string in the form `'custom-name'`, `'<custom-name>'`,\n`'tag is=\"custom-name\"'` or `'<tag is=\"custom-name\">'`\n- `lifecycle`: `{\n    mode:       'open' or 'closed'\n    focusable:  true or false\n    shadow:     html string or '#template-id' or fragment\n\n    // Styleheet\n    stylesheet: optional string path to stylesheet for shadow DOM\n\n    // Lifecycle handlers\n    construct:  called during element construction\n    connect:    called when element added to DOM\n    load:       called when stylesheet loaded\n    disconnect: called when element removed from DOM\n\n    // Form elements\n    enable:     called when form element enabled\n    disable:    called when form element disabled\n    reset:      called when form element reset\n    restore:    called when form element restored\n}`\n- `properties`: `{\n    name: {\n        construct: fn called before lifecycle.construct\n        attribute: fn called on `element.setAttribute('name', ...)`\n        set:       fn called on setting property 'name'\n        get:       fn called on getting property 'name'\n    }\n}`\n- `stylesheet`: url of a stylesheet to load in to the shadow DOM\n- `message`: optional debug message to logged when element is registered\n\nThe name form `'tag is=\"element-name\"'` creates customised built-in elements in\nbrowsers that support the feature. Safari does not, but support is somewhat\npolyfilled. Mileage will vary.\n\n#### Lifecycle\n\nLifecycle handlers are called with the element as `this` and with the parameters\n`shadow` and `internals`.\n\nOn initialisation the `construct` handler is called. Set up the shadow root and\ndefine event handlers here. Children and attributes must not be inspected or\nassigned at this point: doing so will throw an error when constructed via\n`document.createElement()`.\n\nFollowing that, attribute handlers in `properties` are called for attributes\ndeclared in the HTML. The HTML parser normally calls these in source order.\n\nThen the `connect` handler is called when the element is placed in the DOM, or\nif it is already in the DOM and is being upgraded.\n\nBoth `load` and `slotchange` are asynchronous. Things get a little tricky here.\nThe order of `load` callbacks and `'slotchange'` listeners cannot be guaranteed\nin Safari. When there is an empty cache `slotchange` comes first, as it always\ndoes in other browsers, otherwise `load` happens first.\n\nWhere there is a stylesheet loading, most browsers call `'slotchange'` listeners\n(asynchronously) before `load` – except Safari, where if the stylesheet is\nalready cached `load` is called before `'slotchange'` listeners. (TODO: I would\nlike to guarantee `slotchange` before `load`, but it is not clear how to delay\n`load`... if there is no slotted content, `slotchange` may not be called at\nall...)\n\nFinally, `connect` and `disconnect` are called whenever the element is inserted\ninto or removed from the DOM.\n\nThe effects of the `mode` option are subtle. In 'closed' mode, the element is\nnot given a publicly accessible `shadowRoot` property, and events that traverse\nthe shadow boundary are retargeted (as they are in 'open' mode) but also have\ntheir `path` list truncated.\n\n### Properties\n\nWhere the `properties` object contains a definition for a `value` property, work\nis done to give the element form field behaviour. The constructor is assigned\nthe property `formAssociated` which signals to the browser that it constructs\nform fields. Where they are not defined in `properties` the prototype is\nassigned default handlers for the standard properties `type`, `name`, `form`,\n`labels`, `validity`, `validationMessage`, `willValidate`, `checkValidity`\nand `reportValidity`. Form behaviour is also mildly polyfilled in browsers\nwithout support by inserting a hidden input inside the element but outside the\nshadow DOM. Mileage will vary. Managing focus can be problematic without browser\nsupport.\n*/\n\nimport capture  from 'fn/capture.js';\nimport id       from 'fn/id.js';\nimport noop     from 'fn/noop.js';\nimport overload from 'fn/overload.js';\nimport Signal   from 'fn/signal.js';\nimport create   from './create.js';\nimport { createInternals, getInternals } from './element/internals.js';\n\n\nconst define         = Object.defineProperties;\nconst nothing        = {};\nconst constructors   = {};\nconst formProperties = {\n    // These properties echo those provided by native form controls. They are\n    // not strictly required, but provided for consistency with standard form\n    // elements.\n\n    //type: { value: 'text' },\n\n    name: {\n        set: function(name) { return this.setAttribute('name', name); },\n        get: function()     { return this.getAttribute('name') || ''; }\n    },\n\n    form:              { get:   function() { return getInternals(this).form; }},\n    labels:            { get:   function() { return getInternals(this).labels; }},\n    validity:          { get:   function() { return getInternals(this).validity; }},\n    validationMessage: { get:   function() { return getInternals(this).validationMessage; }},\n    willValidate:      { get:   function() { return getInternals(this).willValidate; }},\n    checkValidity:     { value: function() { return getInternals(this).checkValidity(); }},\n    reportValidity:    { value: function() { return getInternals(this).reportValidity(); }}\n};\n\n\nlet supportsCustomisedBuiltIn = false;\n\n\n// Capture name and tag from <element-name> or <tag is=\"element-name\">, syntax\n// brackets and quotes optional\nconst parseNameTag = capture(/^\\s*<?([a-z][\\w]*-[\\w-]+)>?\\s*$|^\\s*<?([a-z][\\w]*)\\s+is[=\\s]*[\"']?([a-z][\\w]*-[\\w-]+)[\"']?>?\\s*$/, {\n    1: (data, captures) => ({\n        name: captures[1]\n    }),\n\n    2: (data, captures) => ({\n        name: captures[3],\n        tag:  captures[2]\n    }),\n\n    catch: function(data, name) {\n        throw new SyntaxError('dom element() – name must be of the form \\'element-name\\' or \\'tag is=\"element-name\"\\' (' + name + ')')\n    }\n}, null);\n\nconst onceEvent = { once: true };\n\nfunction toLoadPromise(element) {\n    return !!element.sheet ?\n        // Link has already loaded\n        Promise.resolve({ target: element }) :\n        // Wait for load\n        new Promise((resolve, reject) => {\n            element.addEventListener('load', resolve, onceEvent);\n            element.addEventListener('error', reject, onceEvent);\n        }) ;\n}\n\nfunction stop(object) {\n    object.stop();\n}\n\nfunction getElementConstructor(tag) {\n    if (constructors[tag]) return constructors[tag];\n\n    const constructor = document.createElement(tag).constructor;\n    if (constructor === HTMLUnknownElement) {\n        throw new Error('Cannot define customised built-in - constructor for <' + tag + '> is HTMLUnknownElement');\n    }\n\n    return constructors[tag] = constructor;\n}\n\nfunction transferProperty(element, key) {\n    if (element.hasOwnProperty(key)) {\n        const value = element[key];\n        delete element[key];\n        element[key] = value;\n    }\n    return element;\n}\n\nfunction createShadow(elem, options) {\n    // Create a shadow root. Shadows may be 'open' or 'closed'. Closed shadows\n    // are not exposed via element.shadowRoot, and events propagating from\n    // inside of them report the element as target. Default to 'closed'.\n    const shadow = elem.attachShadow({\n        mode:           options.mode || 'closed',\n        delegatesFocus: options.focusable || false\n    });\n\n    if (options.stylesheet) {\n        const link = create('link', { rel: 'stylesheet', href: options.stylesheet });\n        shadow.append(link);\n    }\n\n    return shadow;\n}\n\nfunction fillShadowFromTemplate(shadow, template) {\n    // It's a string\n    if (typeof template === 'string') {\n        // It's an id of a template\n        if (template[0] === '#') {\n            shadow.appendChild(\n                document.getElementById(template.slice(1))\n                .content.clone(true)\n            );\n        }\n        // It's html\n        else {\n            shadow.innerHTML = template;\n        }\n    }\n    // It's a <template>\n    else {\n        shadow.appendChild(template.content.clone(true));\n    }\n\n    return shadow;\n}\n\nfunction isNotUpgraded(element) {\n    /* Detect marked as upgraded, mark if not */\n    const upgraded = element.isUpgraded;\n    element.isUpgraded = true;\n    return !upgraded;\n}\n\nfunction findByIs(root, name) {\n    return Array\n    .from(root.querySelectorAll('[is=\"' + name + '\"]'))\n    .filter(isNotUpgraded);\n}\n\nconst createDescriptor = overload((name, options) => typeof options, {\n    object:   (name, descriptor) => descriptor,\n    function: (name, fn) => ({ value: fn }),\n    default:  (name, options) => {\n        throw new TypeError('element() does not accept property descriptor of type ' + typeof options);\n    }\n});\n\nexport default function element(definition, lifecycle = {}, properties = {}, log = '') {\n    const { name, tag } = parseNameTag(definition);\n\n    // Get the element constructor or the base HTMLElement constructor\n    const constructor = typeof tag === 'string' ?\n        getElementConstructor(tag) :\n        HTMLElement ;\n\n    // Split properties into attributes and property descriptors\n    const attributes  = [];\n    const descriptors = {};\n\n    let propname, descriptor;\n    for (propname in properties) {\n        descriptor = createDescriptor(propname, properties[propname]);\n\n        // Add name to list of observed attributes\n        if (descriptor.attribute) attributes.push(propname);\n\n        // Add descriptor to properties to be defined\n        if (descriptor.set || descriptor.get || 'value' in descriptor) descriptors[propname] = descriptor;\n\n        // Override property descriptor\n        properties[propname] = descriptor;\n    }\n\n    // Declare constructor\n    function Element() {\n        // Construct an instance from Constructor using Element prototype\n        const element = Reflect.construct(constructor, arguments, Element);\n\n        // Make shadow if mode or shadow have been set\n        const shadow = (lifecycle.mode || (typeof lifecycle.shadow === 'string')) ?\n            createShadow(element, lifecycle) :\n            undefined ;\n\n        // Fill shadow with template\n        if (lifecycle.shadow) fillShadowFromTemplate(shadow, lifecycle.shadow);\n\n        // Get access to the internals object. If form associated, internals is\n        // the form control API internals object. We're gonna be rude and\n        // extend it.\n        const internals = createInternals(Element, element, shadow);\n\n        // Flag support for custom built-ins. We know this when tag exists and\n        // Element constructor is called\n        if (tag) supportsCustomisedBuiltIn = true;\n        if (lifecycle.construct) lifecycle.construct.call(element, shadow, internals);\n\n        // At this point, if properties have been set before the element was\n        // upgraded they already exist on the element itself, where we have\n        // just upgraded it's protytype to define those properties. Those\n        // definitions will never be reached. Either:\n        //\n        // 1. Define properties on the instance instead of the prototype, as in\n        //    Object.defineProperties(element, descriptors) here in the\n        //    constructor. Won't actually solve the problem.\n        //\n        // 2. Take a great deal of care when authoring not to set properties\n        //    before an element is upgraded. We can't impose a restriction like\n        //    that on Joe Bloggs front end developer.\n        //\n        // 3. Copy defined properties to their prototype handlers and delete\n        //    them on the instance.\n        //\n        // Let's go with 3. I'm not happy we have to do this, though.\n        Object.keys(descriptors).reduce(transferProperty, element);\n\n        // Avoid flash of unstyled content in shadow DOMs that must load assets.\n        if (shadow) {\n            const links = shadow.querySelectorAll('link[rel=\"stylesheet\"]');\n\n            if (links.length) {\n                // Hide all content other than the default slot until stylesheets\n                // have loaded. We keep the default slot visible as that content\n                // was visible before upgrade and we do not want it to momentarily\n                // disappear.\n                const style = create('style', '*:not(slot), slot:not([name]) { display: none !important; }');\n                shadow.prepend(style);\n\n                const promise = Promise\n                .all(Array.from(links, toLoadPromise))\n                .finally(() => {\n                    if (window.DEBUG) window.console.log('%c<' + (tag ? tag + ' is=' + name + '' : name) + '>%c load \\n' + Array.from(links).map((link) => link.href.replace(/https?:\\/\\//, '')).join('\\n'), 'color:#3a8ab0;font-weight:400;', 'color:#888888;font-weight:400;');\n                    // Remove hide style\n                    style.remove();\n                    // and call the load() callback\n                    if (lifecycle.load) lifecycle.load.call(element, shadow, internals);\n                });\n            }\n        }\n\n        return element;\n    }\n\n    // Set prototype and define properties\n    Element.prototype = Object.create(constructor.prototype, descriptors);\n\n    // Prefetch stylesheet ??\n    /*if (stylesheet) {\n        toPrefetchPromise(stylesheet);\n        log = window.DEBUG ?\n            log + ' – stylesheet ' + stylesheet :\n            log ;\n    }*/\n\n    if (properties.value) {\n        // Flag the Element class as formAssociated\n        Element.formAssociated = true;\n\n        // Define standard form properties\n        define(Element.prototype, formProperties);\n\n        if (lifecycle.enable || lifecycle.disable) {\n            Element.prototype.formDisabledCallback = function(disabled) {\n                const internals = getInternals(this);\n                return disabled ?\n                    lifecycle.disable && lifecycle.disable.call(this, internals.shadowRoot, internals) :\n                    lifecycle.enable && lifecycle.enable.call(this, internals.shadowRoot, internals) ;\n            };\n        }\n\n        if (lifecycle.reset) {\n            Element.prototype.formResetCallback = function() {\n                const internals = getInternals(this);\n                return lifecycle.reset.call(this, internals.shadowRoot, internals);\n            };\n        }\n\n        if (lifecycle.restore) {\n            Element.prototype.formStateRestoreCallback = function() {\n                const internals = getInternals(this);\n                return lifecycle.restore.call(this, internals.shadowRoot, internals);\n            };\n        }\n    }\n\n    // Attributes\n    if (attributes.length) {\n        Element.observedAttributes = attributes;\n        Element.prototype.attributeChangedCallback = function(name, old, value) {\n            return properties[name].attribute.call(this, value) ;\n        };\n    }\n\n    // Lifecycle\n    if (lifecycle.connect) {\n        Element.prototype.connectedCallback = function() {\n            const internals = getInternals(this);\n            internals.renderers = lifecycle.connect.call(this, internals.shadowRoot, internals);\n        }\n    }\n\n    Element.prototype.disconnectedCallback = function() {\n        const internals = getInternals(this);\n        if (internals.renderers)  internals.renderers.forEach(stop);\n        if (lifecycle.disconnect) lifecycle.disconnect.call(this, internals.shadowRoot, internals);\n    };\n\n    // Log registration to console\n    window.console &&\n    window.console.log('%c<' + (tag ? tag + ' is=' + name + '' : name) + '>%c ' + log, 'color:#3a8ab0;font-weight:600;', 'color:#888888;font-weight:400;');\n\n    // Define the element\n    window.customElements.define(name, Element, tag && { extends: tag });\n\n\n    // Safari partial polyfill.\n    // Where tag is supplied, element should have been registered as a customised\n    // built-in and the constructor would have run if any were in the DOM already.\n    // However, Safari does not support customised built-ins. Here we attempt to\n    // go some way towards filling in support by searching for elements and\n    // assigning their intended APIs to them.\n    if (tag && !supportsCustomisedBuiltIn) {\n        // It may be there were none in the DOM, in which case we must run a\n        // test. Not ideal.\n        const div = document.createElement('div');\n        div.style.position = 'fixed';\n        div.style.left = '-1000px';\n        div.style.top  = '-1000px';\n        div.innerHTML = '<' + tag + ' is=\"' + name + '\"></' + tag + '>';\n        document.body.append(div);\n        div.remove();\n\n        if (!supportsCustomisedBuiltIn) {\n            if (window.DEBUG) {\n                console.warn('Browser does not support customised built-in elements, polyfilling <' + tag + ' is=\"' + name + '\">');\n            }\n\n            function upgrade(element) {\n                // Define properties on element\n                define(element, descriptors);\n\n                // Construct an instance from Constructor using the Element prototype\n                const shadow = lifecycle.mode || lifecycle.shadow ?\n                    createShadow(element, lifecycle) :\n                    undefined ;\n\n                // Get access to the internals object\n                const internals = createInternals(Element, element, shadow);\n\n                // Run constructor\n                lifecycle.construct && lifecycle.construct.call(element, shadow, internals);\n\n                // Detect and run attributes\n                let n = -1, name;\n                while (name = attributes[++n]) {\n                    // elements.attributes is sometimes undefined... why?\n                    const attribute = element.attributes[name];\n                    if (attribute) properties[name].attribute.call(element, attribute.value);\n                }\n\n                // Run connected callback\n                lifecycle.connect && lifecycle.connect.call(element, shadow, internals);\n            }\n\n            function polyfillByRoot(root) {\n                findByIs(root, name).forEach(upgrade)\n                const observer = new MutationObserver(() => findByIs(root, name).forEach(upgrade));\n                observer.observe(root, { childList: true, subtree: true });\n            }\n\n            // Expose on element for use in shadow DOMs\n            Element.polyfillByRoot = polyfillByRoot;\n\n            // Run on document automatically\n            polyfillByRoot(document);\n        }\n        else {\n            Element.polyfillByRoot = noop;\n        }\n    }\n    else {\n        Element.polyfillByRoot = noop;\n    }\n\n    return Element;\n}\n\nexport { getInternals };\nexport const render = Signal.frame;\n", "\n/**\n<details-toggle>\n\nThe gods of the World Wide Web, in their eternal wisdom, delivered onto us a\n`<details>` element that is impossible to style with opening or closing\ntransitions. So the `<details-toggle>` custom element provides an animated\nalternative.\n\n<details-toggle>\n    <h4 slot=\"summary\">Click to open</h4>\n    Crunchum ipsum dolor sit coder void, constructor function, sed do while loop\n    python orientation semi colon incident. Duis aute irure indent tabs or spaces\n    velit esse cilium buntum how crunchy duntum. Excepteur tranquilis syntax\n    error memorandum qui officia nostrud operating system alertus.\n</details-toggle>\n\n\n## Import\n\n<!--\nDownload the latest release:\n\n[github.com/stephband/details-toggle/releases](https://github.com/stephband/details-toggle/releases)\n-->\n\nInclude the CSS:\n\n```html\n<link rel=\"stylesheet\" href=\"./details-toggle.css\" />\n```\n\nImport and register the `<details-toggle>` custom element, upgrading any\ninstances already in the DOM:\n\n```js\nimport DetailsToggle from './details-toggle.js';\n```\n\n\n## Use\n\nA `details-toggle` is collapsed to the height of its `slot=\"summary\"` content by\ndefault, and opens to display all content when the summary content is clicked.\n\n```html\n<details-toggle>\n    <h4 slot=\"summary\">Click to open</h4>\n    Crunchum ipsum dolor sit coder void, constructor function, sed\n    do while loop python orientation semi colon incident. Duis aute\n    irure indent tabs or spaces velit esse cilium buntum how crunchy\n    duntum.\n</details-toggle>\n```\n**/\n\nimport Signal           from 'fn/signal.js';\nimport create           from 'dom/create.js';\nimport events           from 'dom/events.js';\nimport styles           from 'dom/styles.js';\nimport isPrimaryButton  from 'dom/is-primary-button.js';\nimport { px }           from 'dom/parse-length.js';\nimport { trigger }      from 'dom/trigger.js';\nimport element, { getInternals } from 'dom/element.js';\n\n\nconst assign = Object.assign;\n\n\nfunction animateToOpen(host, element) {\n    // Transition smoothly to open state by calculating and setting the\n    // target maxHeight of the slot for the duration of the transition\n    const scrollHeight  = element.scrollHeight;\n    const computed      = getComputedStyle(element);\n    const paddingTop    = px(computed.getPropertyValue('padding-top') || 0);\n    const paddingBottom = px(computed.getPropertyValue('padding-bottom') || 0);\n\n    events('transitionend', element)\n    .slice(0, 1)\n    .each((e) => element.style.maxHeight = '');\n\n    element.style.maxHeight = (paddingTop + scrollHeight + paddingBottom) + 'px';\n\n    host.setAttribute('open', '');\n}\n\nfunction animateToClose(host, element) {\n    // Transition smoothly to closed state by reading and setting the\n    // maxHeight briefly at the start of the transition\n    const scrollHeight  = element.scrollHeight;\n    const computed      = getComputedStyle(element);\n    const paddingBottom = px(computed.getPropertyValue('padding-bottom') || 0);\n    const marginBottom  = px(computed.getPropertyValue('margin-bottom') || 0);\n\n    element.style.transition    = 'none';\n    element.style.maxHeight     = scrollHeight + 'px';\n    element.style.paddingBottom = paddingBottom + 'px';\n    element.style.marginBottom  = marginBottom + 'px';\n\n    host.removeAttribute('open');\n    host.scrollTop = 0;\n\n    requestAnimationFrame(() => {\n        element.style.transition    = '';\n        element.style.maxHeight     = '';\n        element.style.paddingBottom = '';\n        element.style.marginBottom  = '';\n    });\n}\n\nfunction isIgnorable(e) {\n    // Default is prevented indicates that this click has already\n    // been handled. Save ourselves the overhead of further handling.\n    if (e.defaultPrevented) { return true; }\n\n    // Ignore mousedowns on any button other than the left (or primary)\n    // mouse button, or when a modifier key is pressed.\n    if (!isPrimaryButton(e)) { return true; }\n}\n\nexport default element('<details-toggle>', {\n    focusable: true,\n\n    shadow: `\n        <link rel=\"stylesheet\" href=\"${ window.detailsToggleStylesheet || import.meta.url.replace(/module\\.js$/, 'shadow.css') }\"/>\n    `,\n\n    construct: function(shadow, internals) {\n        // Create a DOM of the form:\n        // <link rel=\"stylesheet\" href=\"/source/bolt/elements/details-toggle.shadow.css\" />\n        // <slot name=\"summary\"><button></button></slot>\n        // <slot></slot>\n        //const style   = styles(':host', shadow)[0];\n        const slot    = create('slot', { part: 'content' });\n        const summary = create('slot', { part: 'summary', name: 'summary' });\n        const button  = create('button', { type: \"button\", html: \"Open\" });\n\n        summary.append(button);\n        shadow.append(summary, slot);\n\n        internals.$open      = Signal.of(false);\n        internals.$loaded    = Signal.of(false);\n        internals.$connected = Signal.of(false);\n        internals.slot       = slot;\n\n        events('click', summary).each((e) => {\n            // Ignore right-clicks, option-clicks\n            if (isIgnorable(e)) { return; }\n            // Prevent default to mark as handled\n            e.preventDefault();\n            // Toggle the element\n            this.open = !this.open;\n        });\n\n        // On pointerdown on a focusable, focus is delegated to the first\n        // focusable element inside its dom, which can make the content slot\n        // scroll up. Put it back down.\n        this.addEventListener('focusin', (e) => slot.scrollTop = 0);\n    },\n\n    connect: function(shadow, { $connected }) {\n        $connected.value = true;\n    },\n\n    disconnect: function(shadow, { $connected }) {\n        $connected.value = false;\n    },\n\n    load: function(shadow, { $loaded }) {\n        $loaded.value = true;\n\n        // If the element is identified by the location hash, open the element\n        const hash = window.location.hash;\n        if (hash && /^#\\S+$/.test(hash) && this.id === hash.slice(1)) {\n            this.open = true;\n        }\n    }\n}, {\n    open: {\n        /**\n        open=\"\"\n        A boolean attribute describing the state of the `details-toggle`.\n        **/\n        attribute: function(value) {\n            this.open = value !== null;\n        },\n\n        /**\n        .open=false\n        A boolean property describing the state of the `details-toggle`: `true`\n        when the `details-toggle` is open, `false` when it is not.\n        **/\n        get: function() {\n            const { $open } = getInternals(this);\n            return $open.value;\n        },\n\n        set: function(value) {\n            const { $connected, $loaded, $open, slot } = getInternals(this);\n\n             // If toggle has not changed do nothing\n            if (!!value === $open.value) return;\n\n            if (value) {\n                $open.value = true;\n\n                // If connected and loaded we can animate\n                if ($connected.value && $loaded.value) animateToOpen(this, slot);\n                // Otherwise we cannot\n                else this.setAttribute('open', '');\n\n                /**\n                'open'\n                Sent from `details-toggle` when opened.\n                **/\n                trigger('open', this);\n            }\n            else {\n                $open.value = false;\n                animateToClose(this, slot);\n\n                /**\n                'close'\n                Sent from `details-toggle` when closed.\n                **/\n                trigger('close', this);\n            }\n        }\n    }\n}, 'stephen.band/details-toggle/');\n", "\n// Classes\nimport '../bolt/classes/device.js';\nimport '../dom/scripts/orphans.js';\nimport '../details-toggle/module.js';\n\nif (window.console && window.console.log) {\n    console.log('-------------------------');\n    console.log('Website by @stephband');\n    console.log('https://stephen.band');\n    console.log('-------------------------');\n}\n"],
  "mappings": "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",
  "names": ["cacheByObject", "fn", "map", "object", "value", "A", "applyFn", "fn", "args", "curry", "muteable", "arity", "memo", "cacheByObject", "object", "partial", "curry_default", "get", "key", "object", "get_default", "curry_default", "classes", "get_default", "classes_default", "_addClass", "string", "node", "_removeClass", "requestFrame", "n", "fn", "frame", "t", "_frameClass", "list", "addClass", "curry_default", "removeClass", "frameClass", "config", "device", "list", "classes_default", "currentClass", "timeStamp", "updateClass", "newClass", "mousedown", "e", "keydown", "touchend", "last", "array", "toArray", "object", "array", "l", "i", "select", "selector", "node", "toArray", "select_default", "curry_default", "isTextNode", "node", "select_default", "get_default", "last", "isTextNode", "node", "$0", "$1", "evaluatingSignal", "removeOutput", "signal", "output", "o", "setDependency", "dependent", "invalidateDependents", "n", "hasInput", "input", "Signal", "_Signal", "object", "value", "ValueSignal", "fn", "context", "ComputeSignal", "name", "PropertySignal", "FrameObserver", "TickObserver", "ObserveSignal", "previous", "evaluatingSignal", "#value", "#valid", "#fn", "#context", "promise", "m", "Observer", "observers", "i", "tick", "frame", "id", "value", "overload", "fn", "map", "key", "handler", "noop", "assignProperty", "overload", "id", "noop", "name", "node", "object", "content", "setAttribute", "assign", "attributes", "names", "n", "assign_default", "curry_default", "svgNamespace", "template", "typeofContent", "type", "content", "createContextFragment", "context", "html", "range", "createSVG", "overload", "tag", "node", "object", "assign_default", "createHTML", "create", "id", "text", "fragment", "create_default", "to_type_default", "object", "assign", "create", "$listeners", "call", "overload", "to_type_default", "fn", "object", "throwTypeError", "source", "push", "stream", "value", "stop", "listeners", "o", "output", "removeInput", "input", "i", "removeOutput", "unpipe", "Consumer", "listener", "Reduce", "accumulator", "Stream", "args", "values", "Buffer", "Filter", "FlatMap", "Map", "initial", "Scan", "n", "m", "Slice", "Split", "setResolve", "res", "rej", "noop", "PromiseStream", "promise", "result", "Merge", "inputs", "chunk", "assign", "rspaces", "types", "cacheByObject", "clickTimeStamp", "e", "listen", "listener", "type", "unlisten", "Events", "options", "node", "initialEvent", "Stream", "selectedTarget", "events", "isPrimaryButton", "e", "runit", "parseValue", "units", "string", "entry", "to_rad_default", "n", "parse_angle_default", "parseValue", "to_rad_default", "id", "n", "string", "rpx", "rangle", "computedStyle", "name", "node", "style", "value", "parse_angle_default", "emSize", "remSize", "getEmSize", "styledFontSize", "style", "getRemSize", "px", "overload", "to_type_default", "id", "parseValue", "n", "assign", "defaults", "trigger", "type", "node", "options", "properties", "detail", "bubbles", "cancelable", "composed", "event", "trigger_default", "curry_default", "exec", "regex", "fn", "string", "data", "tokens", "output", "exec_default", "curry_default", "error", "regex", "reducers", "string", "reduce", "acc", "tokens", "n", "capture", "output", "exec", "capture_default", "curry_default", "$internals", "createInternals", "Element", "element", "shadow", "getInternals", "define", "constructors", "formProperties", "name", "getInternals", "supportsCustomisedBuiltIn", "parseNameTag", "capture_default", "data", "captures", "onceEvent", "toLoadPromise", "element", "resolve", "reject", "stop", "object", "getElementConstructor", "tag", "constructor", "transferProperty", "key", "value", "createShadow", "elem", "options", "shadow", "link", "create_default", "fillShadowFromTemplate", "template", "isNotUpgraded", "upgraded", "findByIs", "root", "createDescriptor", "overload", "descriptor", "fn", "definition", "lifecycle", "properties", "log", "attributes", "descriptors", "propname", "Element", "internals", "createInternals", "links", "style", "promise", "define", "disabled", "old", "div", "noop", "upgrade", "n", "attribute", "polyfillByRoot", "render", "Signal", "animateToOpen", "host", "element", "scrollHeight", "computed", "paddingTop", "px", "paddingBottom", "events", "e", "animateToClose", "marginBottom", "isIgnorable", "isPrimaryButton", "module_default", "shadow", "internals", "slot", "create_default", "summary", "button", "Signal", "$connected", "$loaded", "hash", "value", "$open", "getInternals", "trigger"]
}
